/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`post_files_content`]
#[derive(Clone, Debug, Default)]
pub struct PostFilesContentParams {
    //
    // TODO: the strcutre PostFilesContentRequestAttributes was not found on the documentation
    //
    // pub attributes: crate::models::PostFilesContentRequestAttributes,
    //
    /// The content of the file to upload to Box.  <Message warning>    The `attributes` part of the body must come **before** the   `file` part. Requests that do not follow this format when   uploading the file will receive a HTTP `400` error with a   `metadata_after_file_contents` error code.  </Message>
    pub file: std::path::PathBuf,
    /// A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested.
    pub fields: Option<Vec<String>>,
    /// An optional header containing the SHA1 hash of the file to ensure that the file was not corrupted in transit.
    pub content_md5: Option<String>,
}

/// struct for passing parameters to the method [`post_files_id_content`]
#[derive(Clone, Debug, Default)]
pub struct PostFilesIdContentParams {
    /// The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL `https://_*.app.box.com/files/123` the `file_id` is `123`.
    pub file_id: String,
    //
    // TODO: the strcutre PostFilesContentRequestAttributes was not found on the documentation
    //
    // pub attributes: crate::models::PostFilesIdContentRequestAttributes,
    //
    /// The content of the file to upload to Box.  <Message warning>    The `attributes` part of the body must come **before** the   `file` part. Requests that do not follow this format when   uploading the file will receive a HTTP `400` error with a   `metadata_after_file_contents` error code.  </Message>
    pub file: std::path::PathBuf,
    /// Ensures this item hasn't recently changed before making changes.  Pass in the item's last observed `etag` value into this header and the endpoint will fail with a `412 Precondition Failed` if it has changed since.
    pub if_match: Option<String>,
    /// A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested.
    pub fields: Option<Vec<String>>,
    /// An optional header containing the SHA1 hash of the file to ensure that the file was not corrupted in transit.
    pub content_md5: Option<String>,
}

/// struct for typed errors of method [`post_files_content`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesContentError {
    Status400(crate::models::ClientError),
    Status404(crate::models::ClientError),
    Status409(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_id_content`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesIdContentError {
    Status412(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// Uploads a small file to Box. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
pub async fn post_files_content(
    configuration: &configuration::Configuration,
    params: PostFilesContentParams,
) -> Result<crate::models::Files, Error<PostFilesContentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    //
    //TODO: apparently params.attributes does not exist??
    // let attributes = params.attributes;
    //
    let file = params.file;
    let fields = params.fields;
    let content_md5 = params.content_md5;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/content", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("fields".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "fields",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_md5 {
        local_var_req_builder =
            local_var_req_builder.header("content-md5", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    //
    //TODO: apparently params.attributes does not exist??
    // let mut local_var_form = reqwest::multipart::Form::new();
    // local_var_form = local_var_form.text("attributes", attributes.to_string());
    //     // TODO: support file upload for 'file' parameter
    // local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostFilesContentError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a file's content. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
pub async fn post_files_id_content(
    configuration: &configuration::Configuration,
    params: PostFilesIdContentParams,
) -> Result<crate::models::Files, Error<PostFilesIdContentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let file_id = params.file_id;
    //
    //TODO: apparently params.attributes does not exist??
    // let attributes = params.attributes;
    //
    let file = params.file;
    let if_match = params.if_match;
    let fields = params.fields;
    let content_md5 = params.content_md5;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/files/{file_id}/content",
        local_var_configuration.base_path,
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("fields".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "fields",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder =
            local_var_req_builder.header("if-match", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_md5 {
        local_var_req_builder =
            local_var_req_builder.header("content-md5", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    //
    //TODO: apparently params.attributes does not exist??
    // let mut local_var_form = reqwest::multipart::Form::new();
    // local_var_form = local_var_form.text("attributes", attributes.to_string());
    // // TODO: support file upload for 'file' parameter
    // local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostFilesIdContentError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
